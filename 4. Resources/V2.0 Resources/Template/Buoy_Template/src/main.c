/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.0   2020-06-15

The MIT License (MIT)
Copyright (c) 2018 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */

#include "stm32l4xx_hal.h"	//HAL library includes and micro definitions

#include "Sharc_Frame.h"	//Power config and timing for micro controller

/* Private macro */
/* Private variables */
RTC_HandleTypeDef hrtc;

/* Private function prototypes */
/**
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void);

/**
  * @brief function to handle failiures in Peripheral initialization functions
  * @param None
  * @retval None
  */
void Error_Handler(void);

/**
  * @brief Place code for IMU Event Detection here
  * @param None
  * @retval None
  */
static void Routine_ASYNC_IMU_EVENT(void);

/**
  * @brief Place code for Iridium Message Receive event here
  * @param None
  * @retval None
  */
static void Routine_ASYNC_IRIDIUM_RX(void);

/*
 * @brief Code for Reset State Routine
 * @param None
 * @retval None
 */
static void Routine_STATE_RESET(void);

/*
 * @brief Code for Sleep State Routine
 * @param None
 * @retval None
 */
static void Routine_STATE_SLEEP(void);

/*
 * @brief Code for Sample State Routine
 * @param None
 * @retval None
 */
static void Routine_STATE_SAMPLE(void);

/*
 * @brief Code for Transmit State Routine
 * @param None
 * @retval None
 */
static void Routine_STATE_TRANSMIT(void);

/**
 **===========================================================================
 **
 **  Abstract: main program
 **
 **  IMPORTANT NOTE!
 **  The symbol VECT_TAB_SRAM needs to be defined when building the project
 **  if code has been located to RAM and interrupts are used.
 **  Otherwise the interrupt table located in flash will be used.
 **  See also the <system_*.c> file and how the SystemInit() function updates
 **  SCB->VTOR register.
 **  E.g.  SCB->VTOR = 0x20000000;
 **
 **
 **===========================================================================
 **/

int main(void)
{
//======================== 1. SYSTEM INIT & CLOCK CONFIG ========================//

	HAL_Init();				//Init Flash prefetch, systick timer, NVIC and LL functions
	SystemClock_Config();	//configure clock
	GPIO_Set_Pin_LP();		//Configure all unused GPIO pins to low Power mode
	Init_Debug();			// initialize debug peripherals

//=================================== 1. END ====================================//

//======================= 2. POWER AND RESET STATE CHECK ========================//

/*
 * When system powers on, check for any asynchronous resets that
 * may have occured. Use this area to add in any reset handling
 */
	if(__HAL_RCC_GET_FLAG(RCC_FLAG_BORRST) == SET)
	{
	  BOR_Handler();
	}
	uint8_t flag = __HAL_RCC_GET_PORRST_FLAG();
	if(flag  == SET)
	{
	  printf("Software Reset Detected. Initializing main program...\r\n");
	  POR_Handler();
	}
//=================================== 2. END ====================================//


  /* Infinite loop START */
  while (1)
  {

//========================= 3. ASYNCHRONOUS STATE CHECK ===========================//

	  /*
	   * If an interrupt occurred while the device was sleeping, check the
	   * flags to determine if this occurred
	   */

	  //check for interrupts on wake up pins during deep sleep
	  __HAL_RCC_PWR_CLK_ENABLE();
	  if(__HAL_PWR_GET_FLAG(IMU_EVENT_WAKE_FLAG)|| __HAL_PWR_GET_FLAG(IRIDIUM_RING_WAKE_FLAG))
	  {
		  Current_State = __GET_PREV_STATE();			//get previous state from back up reg
		  if(__HAL_PWR_GET_FLAG(IMU_EVENT_WAKE_FLAG))
		  {
			  __HAL_PWR_CLEAR_FLAG(IMU_EVENT_WAKE_FLAG);	//clear  flag in PWR SR
			  Routine_ASYNC_IMU_EVENT();				//Perform IMU Event Detection Routine
		  }
		  if(__HAL_PWR_GET_FLAG(IRIDIUM_RING_WAKE_FLAG))	//clear  flag in PWR SR
		  {
			__HAL_PWR_CLEAR_FLAG(IRIDIUM_RING_WAKE_FLAG);
			Routine_ASYNC_IRIDIUM_RX();

		  }
		  if(Current_State == STATE_SLEEP)				//return to sleep if Interrupt event handled before wake up
		  {

			  printf("System Going Back To Sleep\r\n"); 	//check how long device was asleep for
			  set_WUP_Pin(IMU_EVENT_WAKE_PIN, MODE_WUP);	//reenable wake up pins
			  set_WUP_Pin(IRIDIUM_RING_WAKE_PIN, MODE_WUP);
			  Go_To_Sleep(STDBY,10);						//return to sleep
		  }
		  	 else
		  {

		  	  printf("Going Back to Main Loop:\r\n");		//if come from wake mode
			  __SET_CURRENT_STATE(STATE_ASYNCINT);
		  }
	  }
//=================================== 3. END ====================================//

//=========================== 4. SYSTEM STATE CHECK =============================//
	  /*
	   * Main Loop state detection: use this area to implement state
	   * check.States are positive integers written to Back up Register
	   * 0. State functions include Reading/ Writing to Back Up register
	   * determing previous state before sleep and writing state to back up register
	   * states are defined in the enum Buoy_State_typedef. The state check block performs the following routine
	   *
	   */

	  //enable access to back up registers
	  switch(__GET_PREV_STATE())
	  {
	  	 case STATE_ASYNCINT:
	  	 case STATE_RESET:
	  	 //system encountered a power on reset, put peripherals here
	  	 Current_State = STATE_SAMPLE;
	  	 break;

	  	 case STATE_SAMPLE:
	  	 //check how many samples have been recorded by the Buoy
	  	 sample_count = __GET_SAMPLE_COUNT();
	  	 if(sample_count > 3)
	  	 {
	  		 //set next Buoy State to Transmit
	  		 Current_State = STATE_TRANSMIT;
	  	 }
	  	 // Set Buoy Next state to Sleep
	  	 else
	  	 {
	  		 Current_State = STATE_SLEEP;
	  		 __HAL_RCC_PWR_CLK_ENABLE();
	  		 __SET_CURRENT_STATE(Current_State);
	  		 __HAL_RCC_PWR_CLK_DISABLE();
	  	 }
	  	 break;

	  	 case STATE_SLEEP:
	  	hrtc.Instance = RTC;					 //attach RTC instance to handler
	  	HAL_PWREx_DisableInternalWakeUpLine();	 //clear wake up pending interrupt from internal wake up
	  	__HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);		 //clear pending interrupt from ext wake up pins
	  	__HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB);
		set_WUP_Pin(IMU_EVENT_WAKE_PIN,MODE_EXTI); 	  	//reconfigure wake up pins
		set_WUP_Pin(IRIDIUM_RING_WAKE_PIN,MODE_EXTI);  	  	//set Current State to Sample
	  	Current_State = STATE_SAMPLE;
	  	 break;

	  	 case STATE_TRANSMIT:
	  	 Current_State = STATE_SLEEP;
  		 __SET_CURRENT_STATE(Current_State);
	  	 break;

	  	 //default case: reset state
	  	 default:
	  	 Current_State = STATE_RESET;
	  }
	  __HAL_RCC_PWR_CLK_DISABLE();

//=================================== 4. END ====================================//

//============================== 5. STATE FUNCTIONS =============================//

	  /*
	   * Place Routine code Here
	   */
	  // SLEEP STATE
	  if(Current_State == STATE_SLEEP)
	  {
		  Routine_STATE_SLEEP();
	  }
	  //RESET STATE
	  else if(Current_State == STATE_RESET)
	  {
		  Routine_STATE_RESET();
	  }
	  //SAMPLE STATE
	  else if(Current_State == STATE_SAMPLE)
	  {
		  Routine_STATE_SAMPLE();
	  }
	  //TRANSMIT STATE
	  else if(Current_State == STATE_TRANSMIT)
	  {
		  Routine_STATE_TRANSMIT();
	  }
	  // ADDITONAL STATE FUNCTIONS HERE:

//=================================== 5. END ====================================//

//========================= 6. END OF ROUTINE FUNCTION ==========================//
	  /*
	   * After each routine has run, save state to the back up registers
	   */
	  __HAL_RCC_PWR_CLK_ENABLE();
	  if(Current_State == STATE_SAMPLE)			//increment sample counter after each sampe
	  {
		  sample_count = __GET_SAMPLE_COUNT();
		  __SET_SAMPLE_COUNT(++sample_count);
	  }
	  __SET_CURRENT_STATE(Current_State);	    //write value to back up register
	  __HAL_RCC_PWR_CLK_DISABLE();

//=================================== 6. END ====================================//
  }
	/* Infinite loop END*/
}

/**
**=======================================================================================
**
**  								END OF MAIN PROGRAM
**
**=======================================================================================
*/

//==================== 7. Configuration & Initialization Functions ====================//

/* Private functions */

static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime = {0};
  RTC_DateTypeDef sDate = {0};

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    Error_Handler();
  }

  /* USER CODE BEGIN Check_RTC_BKUP */

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 12;
  sTime.Minutes = 57;
  sTime.Seconds = 0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
  {
    Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_FRIDAY;
  sDate.Month = RTC_MONTH_MAY;
  sDate.Date = 8;
  sDate.Year = 0;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RTC_Init 2 */
  //Configure RTC_Wake up time for range 250ms - 36 Hours
  if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc,RTC_FLAG_WUTF))
  {
	  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc,RTC_FLAG_WUTF);
  }

  /* USER CODE END RTC_Init 2 */

}

//====================================== 7. END ======================================//

//==================================== 8. Handlers ===================================//

void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

//===================================== 8. END ======================================//

//=============================== 9. Routines =======================================//

static void Routine_ASYNC_IMU_EVENT(void)
{
	 printf("IMU Event Detected: Sampling...");
	 for (int i = 0; i < 50; ++i)
	 {
	 	HAL_GPIO_TogglePin(LD2_GPIO_Port,LD2_Pin);
	 	HAL_Delay(100);
	 }
	 printf("Done\r\n");
}

static void Routine_ASYNC_IRIDIUM_RX(void)
{
	printf("Incoming Message from Satellite: Receiving...");
	for (int i = 0; i < 10; ++i)
	{
		HAL_GPIO_TogglePin(LD2_GPIO_Port,LD2_Pin);
		HAL_Delay(500);
	}
	printf("Message Received!\r\n");
}

static void Routine_STATE_RESET(void)
{
	 //initialise RTC
	 MX_RTC_Init();

	 set_WUP_Pin(IRIDIUM_RING_WAKE_PIN,MODE_EXTI);
	 set_WUP_Pin(IMU_EVENT_WAKE_PIN,MODE_EXTI);
	 printf("All Systems Online!\r\n");
	 printf("Current State: RESET \t Next State: SAMPLE\r\n");
	 HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,SET);
	 //Enable Interrupt pins as EXTI Outputs
}

static void Routine_STATE_SLEEP(void)
{
	  printf("Current State: SLEEP \t Next State: SAMPLE\r\n");
	  printf("Good Night! \r\n");
	  set_WUP_Pin(IRIDIUM_RING_WAKE_PIN,MODE_WUP);
	  set_WUP_Pin(IMU_EVENT_WAKE_PIN,MODE_WUP);
	  Go_To_Sleep(STDBY,10);
}

static void Routine_STATE_SAMPLE(void)
{
	  sample_count = __GET_SAMPLE_COUNT();
	  if(sample_count < 3)
	  {
		  printf("Current State: SAMPLE \t Next State: SLEEP\r\n");
	  } else
	  {
		  printf("Current State: SAMPLE \t Next State: TRANS\r\n");
	  }
	  //TODO: SAMPLE SENSORS:

	  //increment sample counter
	  //routine: Flash LED 3 times every 500 ms
	  for (int var = 0; var < 6; ++var)
	  {
		  HAL_GPIO_TogglePin(LD2_GPIO_Port,LD2_Pin);
		  HAL_Delay(250);
	  }
}

static void Routine_STATE_TRANSMIT(void)
{
	  printf("Current State: TRANS \t Next State: SLEEP\r\n");
	  printf("Transmitting Package...");
	  for (int var = 0; var < 6; ++var)
	  {
		  HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,SET);
		  HAL_Delay(500);
		  HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,RESET);
		  HAL_Delay(250);
	  }
	  printf("Done!\r\n");
	  //reset sample count
	  __SET_SAMPLE_COUNT(0);
}

//===================================== 9. END ======================================//
